> 编写:[jdneo](https://github.com/jdneo)

> 校对:

# 解决云同步的保存冲突

这篇文章介绍了当应用使用[Cloud Save service](http://developers.google.com/games/services/common/concepts/cloudsave)存储数据到云端时，如何设计一个鲁棒性较高的冲突解决策略。云存储服务允许你为每一个在Google服务上的应用用户，存储他们的应用数据。你的应用可以通过使用云存储API，从Android设备，iOS设备或者web应用恢复或更新这些数据。

在云存储过程中的保存和加载是很直接的：它只是一个数据和byte数组之间的相互转换，并将这些数组存储在云端。然而，当你的用户有多个设备，并且两个以上的设备尝试将它们的数据存储在云端时，这一保存可能会引起冲突，因此你必须决定应该如何处理。你在云端存储的数据结构在很大程度上决定了你的冲突解决方案的鲁棒性，所以小心地设计你的数据，使得你的冲突检测解决方案的逻辑可以正确地处理每一种情况。

本篇文章从描述一些有缺陷的方法入手，并解释他们为何具有缺陷。之后呈现一个解决方案来避免冲突。用于讨论的例子关注于游戏，但解决问题的宗旨是可以适用于任何将数据存储于云端的应用的。

##冲突时获得通知

[OnStateLoadedListener](http://developer.android.com/reference/com/google/android/gms/appstate/OnStateLoadedListener.html)方法负责从Google服务器下载应用的状态数据。回调函数[OnStateLoadedListener.onStateConflict](http://developer.android.com/reference/com/google/android/gms/appstate/OnStateLoadedListener.html#onStateConflict)为你的应用在本地状态和云端存储的状态发生冲突时，提供了一个解决机制：

```java
@Override
public void onStateConflict(int stateKey, String resolvedVersion,
    byte[] localData, byte[] serverData) {
    // resolve conflict, then call mAppStateClient.resolveConflict()
 ...
}
```

此时你的应用必须决定要保留哪一个数据，或者它自己提交一个新的数据来表示合并后的数据状态，解决冲突的逻辑由你来实现。

我们必须要意识到云存储服务是在后台执行同步的。所以你应该确保你的应用能够在你创建这一数据的context之外接收回调。特别地，如果Google Play服务应用在后台检测到了一个冲突，该回调函数可以在你下一次加载数据时被调用，而不是下一次用户启动该应用时。

因此，你的云存储代码和冲突解决代码的设计必须是和当前context无关的：即给两个冲突的数据，你必须仅通过数据集中获取的数据区解决冲突，而不依赖于任何其它外部环境。

##处理简单情况

下面列举一些冲突解决的简单例子。对于很多应用而言，用这些策略或者其变体就足够解决大多数问题了：

**新的比旧的更有效：**在一些情况下，新的数据总是替代老数据。例如，如果数据代表了用户选择角色的衣服颜色，那么最近的新的选择就应该覆盖老的选择。在这种情况下，你可能会选择在云存储数据中存储时间戳。当处理这些冲突时，选择时间戳最新的数据（记住要选择一个可靠的时钟，并注意对不同时区的处理）。

**一个数据好于其他数据：**在一些情况下，我们是可以有方法在若干数据集中选取一个最好的。例如，如果数据代表了玩家在赛车比赛中的最佳时间，那么显然，在冲突发生时，你应该保留成绩最好的那个数据。

**进行合并：**有可能通过计算两个数据集的合并版本来解决冲突。例如，如果你的数据代表了用户解锁关卡的进度，那么解决的数据就是冲突集的并集。通过这个方法，用户不会丢失任何他的游戏进度。这里的[例子](https://github.com/playgameservices/android-samples/tree/master/CollectAllTheStars)使用了这一操作的一个变形。

##为更复杂的情况设计一个策略

一个更复杂的情况是当你的游戏允许玩家收集可以互换的东西时（比如金币或者经验点数），我们来假想一个游戏，叫做“金币跑酷”，一个无限跑步的角色,其目标是不断地收集金币是自己变的富有。每个收集到的金币都会加入到玩家的储蓄罐中。

下面的章节将展示三种在多个设备间解决冲突的方案：有两个听上去很不错，可惜最终还是不能适用于所有的场景，最后一个解决方案可以解决多个设备间的冲突。

###第一个尝试：只保存总数

首先，这个问题看上去像是说：云存储的数据只要存储金币的数量就行了。但是如果就只有这些数据是可用的，那么解决冲突的方案将会严重受到限制。此时最佳的方案就是在冲突发生时存储数值最大的数据。

想一下表一中所展现的场景。假设玩家一开始有20枚硬币，然后再设备A上收集了10个，在设备B上收集了15个。然后设备B将数据存储到了云端。当设备A尝试去存储的时候，冲突发生了。“只存储总数”的冲突解决方案会存储35作为这一数据的值（两数之间最大的）。

表1. 值保存最大的数（不佳的策略）

|事件|设备A的数据|设备B的数据|云端的数据|实际的总数|
|----|-----------|-----------|----------|----------|

